# -*- coding: utf-8 -*-
"""App.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12JB-8aOdiXIDgCQnGNkOLthSAKxm342v
"""

#from google.colab import drive
#drive.mount('/content/gdrive')

import os
import argparse
import cv2
import numpy as np
import pandas as pd 
import joblib
import os
from imutils import paths
from skimage import feature
from skimage import io
from skimage.feature import greycomatrix, greycoprops
from sklearn.cluster import KMeans
from matplotlib import pyplot as plt
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from matplotlib import pyplot as plt
from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.utils.multiclass import unique_labels
from sklearn.metrics.pairwise import chi2_kernel
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score
from sklearn.ensemble import RandomForestClassifier

# Definitions
def getDescriptors(sift, img):
    kp, des = sift.detectAndCompute(img, None)
    return kp, des

def clusterDescriptors(descriptors, no_clusters):
    kmeans = KMeans(n_clusters = no_clusters).fit(descriptors)
    return kmeans

def extractFeatures(kmeans, descriptor, no_clusters):
    im_features = np.array(np.zeros(no_clusters))
    for j in range(len(descriptor)):
        feature = descriptor[j]
        feature = feature.reshape(1, 128)
        idx = kmeans.predict(feature)
        im_features[idx] += 1
    return im_features

def show_img_with_matplotlib(color_img, title, pos):
    """Shows an image using matplotlib capabilities"""

    # Convert BGR image to RGB
    img_RGB = color_img[:, :, ::-1]

    ax = plt.subplot(3, 4, pos)
    plt.imshow(img_RGB)
    plt.title(title)
    plt.axis('off')

def show_hist_with_matplotlib_rgb(hist, title, pos, color):
    """Shows the histogram using matplotlib capabilities"""

    ax = plt.subplot(3, 4, pos)
    # plt.title(title)
    plt.xlabel("bins")
    plt.ylabel("number of pixels")
    plt.xlim([0, 256])

    for (h, c) in zip(hist, color):
        plt.plot(h, color=c)

def hist_color_img(img):
    """Calculates the histogram for a three-channel image"""

    histr = []
    histr.append(cv2.calcHist([img], [0], None, [256], [0, 256]))
    histr.append(cv2.calcHist([img], [1], None, [256], [0, 256]))
    histr.append(cv2.calcHist([img], [2], None, [256], [0, 256]))
    return histr

def equalize_hist_color_hsv(img):
    """Equalizes the image splitting it after HSV conversion and applying cv2.equalizeHist()
    to the V channel, merging the channels and convert back to the BGR color space"""

    H, S, V = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))
    eq_V = cv2.equalizeHist(V)
    eq_image = cv2.cvtColor(cv2.merge([H, S, eq_V]), cv2.COLOR_HSV2BGR)
    return eq_image

def data_url_to_cv2_img(url):
    encoded_data = url.split(',')[1]
    nparr = np.fromstring(encoded_data.decode('base64'), np.uint8)
    img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    return img

def process_img(IMG):
    # color_img = cv2.imread(IMG)
    color_img = data_url_to_cv2_img(IMG)
    resized_img = cv2.resize(color_img, (1000, 1000))
    # final_img = resized_img[350:650, 350:650]
    final_img = resized_img[214:514, 214:514]
    gray_img = cv2.cvtColor(final_img, cv2.COLOR_BGR2GRAY)
    sift = cv2.xfeatures2d.SIFT_create()
    feature_list = []

    # kp, des = getDescriptors(sift, final_img)
    kp, des = getDescriptors(sift, gray_img)

    kmeans = clusterDescriptors(des, 40)
    im_features = extractFeatures(kmeans, des, 40)
    feature_list.append(im_features)

    lbp_features = []
    gray = cv2.cvtColor(gray_img, cv2.COLOR_BGR2GRAY)
    lbp = feature.local_binary_pattern(gray, 24, 8, method="uniform")
    (hist, _) = np.histogram(lbp.ravel(), bins=np.arange(0, 27), range=(0, 26))
    hist = hist.astype("float")
    hist /= (hist.sum() + 1e-7)
    lbp_features.append(hist)



    hsv_features = []

    hist_color = hist_color_img(final_img)
    image_eq = equalize_hist_color_hsv(final_img)
    # Equalize the image and calculate histogram:
    hist_image_eq = hist_color_img(image_eq)
    # Add 15 to every pixel on the grayscale image (the result will look lighter) and calculate histogram
    M = np.ones(final_img.shape, dtype="uint8") * 15
    added_image = cv2.add(final_img, M)
    hist_color_added_image = hist_color_img(added_image)
    # Equalize image and calculate histogram
    added_image_eq = equalize_hist_color_hsv(added_image)
    hist_added_image_eq = hist_color_img(added_image_eq)
    # Subtract 15 from every pixel (the result will look darker) and calculate histogram
    subtracted_image = cv2.subtract(final_img, M)
    hist_color_subtracted_image = hist_color_img(subtracted_image)
    # Equalize image and calculate histogram
    subtracted_image_eq = equalize_hist_color_hsv(subtracted_image)
    hist_subtracted_image_eq = hist_color_img(subtracted_image_eq)
    temp_feature = []
    for el in hist_image_eq[0] :
        temp_feature.append(el)
    for el in hist_image_eq[1] :
        temp_feature.append(el)
    hsv_features.append(temp_feature)

    humoment_features = []

    M = np.float32([[1, 0, 25], [0, 1, 50]])
    translated = cv2.warpAffine(gray_img, M, (gray_img.shape[1], gray_img.shape[0]))
    (h, w) = gray_img.shape[:2]
    (cX, cY) = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D((cX, cY), 45, 1.0)
    rotated = cv2.warpAffine(gray_img, M, (w, h))
    flipped = cv2.flip(gray_img, 1)
    down_width = 250
    down_height = 250
    down_points = (down_width, down_height)
    resized_down = cv2.resize(gray_img, down_points, interpolation= cv2.INTER_LINEAR)

    gray_image_1 = cv2.cvtColor(translated, cv2.COLOR_BGR2GRAY)
    gray_image_2 = cv2.cvtColor(rotated, cv2.COLOR_BGR2GRAY)
    gray_image_3 = cv2.cvtColor(flipped, cv2.COLOR_BGR2GRAY)
    gray_image_4 = cv2.cvtColor(resized_down, cv2.COLOR_BGR2GRAY)

    # Apply cv2.threshold() to get a binary image:
    ret_1, thresh_1 = cv2.threshold(gray_image_1, 70, 255, cv2.THRESH_BINARY)
    ret_2, thresh_2 = cv2.threshold(gray_image_2, 70, 255, cv2.THRESH_BINARY)
    ret_3, thresh_3 = cv2.threshold(gray_image_3, 70, 255, cv2.THRESH_BINARY)
    ret_4, thresh_4 = cv2.threshold(gray_image_4, 70, 255, cv2.THRESH_BINARY)

    # Compute Hu moments cv2.HuMoments():
    HuM_1 = cv2.HuMoments(cv2.moments(thresh_1, True)).flatten()
    HuM_2 = cv2.HuMoments(cv2.moments(thresh_2, True)).flatten()
    HuM_3 = cv2.HuMoments(cv2.moments(thresh_3, True)).flatten()
    HuM_4 = cv2.HuMoments(cv2.moments(thresh_4, True)).flatten()
    temp_feature=[]
    for i in range(0, 7):
        temp_feature.append(max(HuM_1[i], HuM_2[i], HuM_3[i], HuM_4[i]))
    humoment_features.append(temp_feature)

    harallik_features = []

    temp_feature =[]
    gray = cv2.cvtColor(gray_img, cv2.COLOR_BGR2GRAY)
    GLCM = greycomatrix(gray, [2], [0], 256, symmetric=True, normed = True)
    #contrast = greycoprops(GLCM, prop = 'contrast')
    dissimilarity = greycoprops(GLCM, prop = 'dissimilarity')
    homogeneity = greycoprops(GLCM, prop = 'homogeneity')
    #energy = greycoprops(GLCM, prop = 'energy')
    correlation = greycoprops(GLCM, prop = 'correlation')
    temp_feature.append(dissimilarity[0][0])
    temp_feature.append(homogeneity[0][0])
    temp_feature.append(correlation[0][0])
    GLCM = greycomatrix(gray, [2], [np.pi/4], 256, symmetric=True, normed = True)
    #contrast = greycoprops(GLCM, prop = 'contrast')
    dissimilarity = greycoprops(GLCM, prop = 'dissimilarity')
    homogeneity = greycoprops(GLCM, prop = 'homogeneity')
    #energy = greycoprops(GLCM, prop = 'energy')
    correlation = greycoprops(GLCM, prop = 'correlation')
    temp_feature.append(dissimilarity[0][0])
    temp_feature.append(homogeneity[0][0])
    temp_feature.append(correlation[0][0])
    GLCM = greycomatrix(gray, [2], [np.pi/2], 256, symmetric=True, normed = True)
    #contrast = greycoprops(GLCM, prop = 'contrast')
    dissimilarity = greycoprops(GLCM, prop = 'dissimilarity')
    homogeneity = greycoprops(GLCM, prop = 'homogeneity')
    #energy = greycoprops(GLCM, prop = 'energy')
    correlation = greycoprops(GLCM, prop = 'correlation')
    temp_feature.append(dissimilarity[0][0])
    temp_feature.append(homogeneity[0][0])
    temp_feature.append(correlation[0][0])
    GLCM = greycomatrix(gray, [2], [np.pi], 256, symmetric=True, normed = True)
    #contrast = greycoprops(GLCM, prop = 'contrast')
    dissimilarity = greycoprops(GLCM, prop = 'dissimilarity')
    homogeneity = greycoprops(GLCM, prop = 'homogeneity')
    energy = greycoprops(GLCM, prop = 'energy')
    correlation = greycoprops(GLCM, prop = 'correlation')
    temp_feature.append(dissimilarity[0][0])
    temp_feature.append(homogeneity[0][0])
    temp_feature.append(correlation[0][0])
    temp_feature.append(energy[0][0])
    harallik_features.append(temp_feature)

    Total_features = []
    temp_features = []
    temp_features.extend(feature_list[0])
    temp_features.extend(lbp_features[0])
    temp_features.extend(harallik_features[0])
    temp_features.extend(humoment_features[0])
    temp_features.extend(hsv_features[0])
    Total_features.extend(temp_features)

    X = pd.DataFrame(Total_features).T

    loaded_rf = joblib.load("/content/gdrive/MyDrive/Dataset/random_forest.joblib")
    preds = loaded_rf.predict(X)

    return preds





